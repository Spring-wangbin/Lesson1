1.Spring是分层的Java SE/EE full-stack轻量级开源框架，以IOC、AOP为内核，取代了EJB低效的开发模式。
    分为三层：表现层（web）、业务逻辑层（service）、持久层（dao）

2.Spring的IOC设计思想
    Spring提供了两种IOC容器：BeanFactory和ApplicationContext,其中ApplicationContext是BeanFactory的子接口。
    两者都是通过xml配置文件加载Bean的
    两者的区别：
        Bean的某一个属性没有注入，使用BeanFactory加载后，第一次调用getBean()方法时会抛出异常，ApplicationContext会在初始化时自检。
        实际开发中，常用ApplicationContext

3.依赖注入：
    依赖注入（Dependency Injection，DI）和控制反转含义相同，它们是从两个角度描述的同一个概念。
    依赖注入的两种方式：
        属性setter注入：
            IOC容器使用setter方法注入被依赖的实例。
            通过调用无参构造器或无参static工厂方法实例化bean后，调用该bean的setter方法
        构造注入：
            IOC容器通过构造方法注入被依赖的实例，通过带参数的构造方法实现，每个参数代表一个依赖

4.bean的实例化：
    构造器实例化：
        <bean id="person1" class="com.mengma.instance.constructor.Person1" />
    静态工厂方式实例化：
        public class MyBeanFactory {
            // 创建Bean实例的静态工厂方法
            public static Person2 createBean() {
                return new Person2();
            }
        }
        <bean id="person2" class="com.mengma.instance.static_factory.MyBeanFactory"
                factory-method="createBean" />
    实例工厂方式实例化：
        public class MyBeanFactory {
            public MyBeanFactory() {
                System.out.println("person3工厂实例化中");
            }
            // 创建Bean的方法
            public Person3 createBean() {
                return new Person3();
            }
        }
        <!-- 配置实例工厂 -->
        <bean id="myBeanFactory" class="com.mengma.instance.factory.MyBeanFactory" />
        <!-- factory-bean属性指定一个实例工厂，factory-method属性确定使用工厂中的哪个方法 -->
        <bean id="person3" factory-bean="myBeanFactory" factory-method="createBean" />

5.bean的作用域：
    singleton：单例模式，在容器中只有一个实例，是Bean的默认作用域。
    prototype：原型模式，每次通过spring容器获取bean时，容器都会创建一个新的Bean实例
    request：一次Http请求中，容器返回同一个实例。对不同的Http请求，返回不同的实例。作用域只对当前Http Request内有效
    session：在一次 HTTP Session 中，容器会返回该 Bean 的同一个实例。而对不同的 HTTP 请求，会返回不同的实例，该作用域仅在当前 HTTP Session 内有效
    global Session：在一个全局的 HTTP Session 中，容器会返回该 Bean 的同一个实例。该作用域仅在使用 portlet context 时有效
    singleton\prototype两种作用域最常用

6.Bean的装配方式：
    基于XML装配Bean：
        <!-- 使用设值注入方式装配Person实例 -->
        <bean id="person1" class="com.mengma.assembly.Person">
            <property name="name" value="zhangsan" />
            <property name="age" value="20" />
        </bean>
        <!-- 使用构造方法装配Person实例 -->
        <bean id="person2" class="com.mengma.assembly.Person">
            <constructor-arg index="0" value="lisi" />
            <constructor-arg index="1" value="21" />
        </bean>
    基于注解Annotation装配：
        @Component：类注解，泛化的概念，j仅仅表示一个组件（bean）
        @Repository：用于将数据访问层（DAO层）的类标识为bean，功能与@Component相同
        @Service：作用在业务层（Service层），功能与@Component相同
        @Controller：作用在控制层，功能与@Component相同
        @Autowired：对Bean的属性变量、属性的Set方法及构造函数进行标注，配合对应的注解处理器完成Bean的自动配置工作。默认按照Bean的类型进行装配
        @Resource：作用与Autowired一样。区别：Resource默认按照Bean的名称进行装配
            @Resource 中有两个重要属性：name 和 type。
            Spring 将 name 属性解析为 Bean 实例名称，type 属性解析为 Bean 实例类型。如果指定 name 属性，则按实例名称进行装配；如果指定 type 属性，则按 Bean 类型进行装配。
            如果都不指定，则先按 Bean 实例名称装配，如果不能匹配，则再按照 Bean 类型进行装配；如果都无法匹配，则抛出 NoSuchBeanDefinitionException 异常。
        @Qualifier：与@Autowired注解配合使用，会将默认按照Bean类型装配修改为按照Bean的名称装配，Bean的实例名称由@Qualifier注解的参数指定
    自动装配：
        自动装配指Spring容器可以自动装配（autowire）相互协作的Bean之间的关联关系，将一个Bean注入其他Bean的Property中
        自动装配需要配置<bean>的autowire属性。（默认情况下不使用自动装配，必须通过ref元素定义）

7.Spring AOP(面向切面编程):
